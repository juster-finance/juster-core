""" Test where provided liquidity is less than 1 share """

from pytezos import MichelsonRuntimeError

from tests.interpret.juster.juster_base import ONE_HOUR
from tests.interpret.juster.juster_base import RUN_TIME
from tests.interpret.juster.juster_base import JusterBaseTestCase


class PrecisionExploitTest(JusterBaseTestCase):
    def _start_measurement_and_then_close(self):

        # In the end: no one bets, starting measure:
        bets_close = self.default_event_params['betsCloseTime']
        period = self.default_event_params['measurePeriod']
        self.current_time = bets_close

        # Emulating callback:
        callback_values = {
            'currencyPair': self.currency_pair,
            'lastUpdate': self.current_time,
            'rate': 6_000_000,
        }
        self.start_measurement(
            callback_values=callback_values,
            source=self.a,
            sender=self.oracle_address,
        )

        # Closing event:
        self.current_time = bets_close + period

        # Emulating calback with price is increased 25%:
        callback_values = {
            'currencyPair': self.currency_pair,
            'lastUpdate': self.current_time,
            'rate': 7_500_000,
        }
        self.close(
            callback_values=callback_values,
            source=self.a,
            sender=self.oracle_address,
        )

    def test_precision_exploit(self):
        self.current_time = RUN_TIME
        self.id = self.storage['nextEventId']

        self.new_event(
            event_params=self.default_event_params,
            amount=self.measure_start_fee + self.expiration_fee,
        )

        # A provides 10k tez in liquidity with success:
        self.provide_liquidity(
            participant=self.a,
            amount=10_000_000_000,
            expected_above_eq=1,
            expected_below=1,
        )

        # B provides 10mutez in liquidity without success:
        with self.assertRaises(MichelsonRuntimeError) as cm:
            self.provide_liquidity(
                participant=self.b,
                amount=10,
                expected_above_eq=1,
                expected_below=1,
            )
        msg = 'Added liquidity is less than one share'
        self.assertTrue(msg in str(cm.exception))

        self._start_measurement_and_then_close()

        # self.withdraw(self.b, 10)
        self.withdraw(self.a, 10_000_000_000)

    def test_zero_liquidity_to_one_pool(self):
        self.current_time = RUN_TIME
        self.id = self.storage['nextEventId']

        self.new_event(
            event_params=self.default_event_params,
            amount=self.measure_start_fee + self.expiration_fee,
        )

        # A provides 100 mutez is succeed with ratio 1:20:
        self.provide_liquidity(
            participant=self.a,
            amount=100,
            expected_above_eq=1,
            expected_below=20,
        )

        # A provides 9 mutez in liquidity with no success:
        # 0.05*9 in one pool and 1*9 in another:
        with self.assertRaises(MichelsonRuntimeError) as cm:
            self.provide_liquidity(
                participant=self.a,
                amount=9,
                expected_above_eq=1,
                expected_below=20,
            )
        msg = 'Zero liquidity provided'
        self.assertTrue(msg in str(cm.exception))

    def test_bet_is_a_lot_higher(self):
        self.current_time = RUN_TIME
        self.id = self.storage['nextEventId']

        self.new_event(
            event_params=self.default_event_params,
            amount=self.measure_start_fee + self.expiration_fee,
        )

        # A provides 1 mutez in liquidity with success:
        self.provide_liquidity(
            participant=self.a, amount=1, expected_above_eq=1, expected_below=1
        )

        # B bets 1 bln tez and wins:
        one_billion = 1_000_000_000_000_000
        self.bet(
            participant=self.b,
            amount=one_billion,
            bet='aboveEq',
            minimal_win=one_billion,
        )

        self._start_measurement_and_then_close()
        self.withdraw(self.b, one_billion)
        self.withdraw(self.a, 1)

    def test_bet_is_a_lot_higher_2(self):
        self.current_time = RUN_TIME
        self.id = self.storage['nextEventId']

        self.new_event(
            event_params=self.default_event_params,
            amount=self.measure_start_fee + self.expiration_fee,
        )

        # A provides 1 mutez in liquidity with success:
        self.provide_liquidity(
            participant=self.a, amount=1, expected_above_eq=1, expected_below=1
        )

        # B bets 1 bln tez and loose:
        one_billion = 1_000_000_000_000_000
        self.bet(
            participant=self.b,
            amount=one_billion,
            bet='below',
            minimal_win=one_billion,
        )

        self._start_measurement_and_then_close()
        self.withdraw(self.b, 0)
        self.withdraw(self.a, one_billion + 1)
